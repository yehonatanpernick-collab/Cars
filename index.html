<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TITAN ELITE: NEURAL COMBAT</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

        :root {
            --neon-cyan: #00f3ff;
            --neon-red: #ff003c;
            --neon-gold: #ffd700;
            --hud-bg: rgba(0, 10, 20, 0.85);
            --glass: rgba(255, 255, 255, 0.1);
        }

        body { margin: 0; background: #000; overflow: hidden; font-family: 'Share Tech Mono', monospace; color: white; user-select: none; }
        
        #titan-os { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

        /* Video Layer */
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 1; z-index: 0; }
        
        /* Game Canvas */
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; transform: scaleX(-1); }

        /* HUD Interface */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* Top Stats Bar */
        .top-bar {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
        }
        .stat-module { text-align: center; border: 1px solid var(--neon-cyan); padding: 5px 15px; background: rgba(0,0,0,0.6); box-shadow: 0 0 10px var(--neon-cyan); transform: skewX(-15deg); }
        .stat-val { font-size: 1.5rem; color: #fff; font-weight: bold; }
        .stat-label { font-size: 0.8rem; color: var(--neon-cyan); letter-spacing: 2px; }

        /* Health & Stamina Bars */
        .bars-wrapper { position: absolute; bottom: 30px; width: 100%; padding: 0 50px; display: flex; justify-content: space-between; align-items: flex-end; box-sizing: border-box; }
        
        .player-hud, .enemy-hud { width: 40%; }
        
        .bar-frame { height: 20px; background: #333; border: 2px solid #555; transform: skewX(-20deg); margin-bottom: 5px; position: relative; overflow: hidden; }
        .hp-fill { height: 100%; width: 100%; transition: width 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .stamina-fill { height: 10px; width: 100%; background: var(--neon-gold); transition: width 0.5s; }
        
        #p-hp { background: var(--neon-cyan); box-shadow: 0 0 15px var(--neon-cyan); }
        #e-hp { background: var(--neon-red); box-shadow: 0 0 15px var(--neon-red); }

        /* Tactical Center Ring */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 300px; height: 300px; border: 2px dashed rgba(0, 243, 255, 0.3);
            border-radius: 50%; pointer-events: none; transition: 0.1s;
        }

        /* Message Log */
        #comms-log {
            position: absolute; top: 20%; right: 20px; width: 250px;
            text-align: right; font-size: 0.9rem; text-shadow: 1px 1px 2px black;
        }
        .log-entry { margin-bottom: 5px; opacity: 0.8; border-right: 3px solid var(--neon-cyan); padding-right: 10px; animation: fadeIn 0.3s; }

        /* Effects */
        .damage-flash { animation: redFlash 0.3s ease-out; }
        @keyframes redFlash { 0% { box-shadow: inset 0 0 0 0 red; } 50% { box-shadow: inset 0 0 100px 50px red; } 100% { box-shadow: inset 0 0 0 0 red; } }
        
        @keyframes scanline { 0% { top: 0%; } 100% { top: 100%; } }
        .scan-fx { position: absolute; width: 100%; height: 5px; background: rgba(0, 255, 255, 0.3); opacity: 0.5; animation: scanline 3s infinite linear; pointer-events: none; z-index: 8; }

        /* Menu */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        h1 { font-family: 'Orbitron', sans-serif; font-size: 4rem; color: white; text-shadow: 0 0 30px var(--neon-cyan); margin-bottom: 0; }
        .menu-btn {
            background: transparent; color: var(--neon-cyan); border: 2px solid var(--neon-cyan);
            padding: 20px 60px; font-size: 1.5rem; margin: 15px; cursor: pointer;
            font-family: 'Orbitron'; letter-spacing: 3px; transition: 0.3s;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }
        .menu-btn:hover { background: var(--neon-cyan); color: black; box-shadow: 0 0 40px var(--neon-cyan); }
        
        .loading { color: var(--neon-gold); margin-top: 20px; animation: blink 1s infinite; display: none; }
        @keyframes blink { 50% { opacity: 0; } }

    </style>
</head>
<body>

<div id="titan-os">
    <div id="menu-overlay">
        <h1>TITAN ELITE</h1>
        <p style="color:#888; letter-spacing:5px; margin-bottom:50px;">NEURAL COMBAT SYSTEM V3.0</p>
        
        <button class="menu-btn" onclick="bootSystem('coach')">TRAINING PROTOCOL</button>
        <button class="menu-btn" style="border-color:var(--neon-red); color:var(--neon-red);" onclick="bootSystem('fight')">COMBAT SIMULATION</button>
        
        <div id="loader" class="loading">INITIALIZING NEURAL NETWORKS...</div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <div class="scan-fx"></div>
    <canvas id="game-canvas"></canvas>

    <div id="hud-layer" style="display:none;">
        <div class="top-bar">
            <div class="stat-module">
                <div class="stat-val" id="score-val">0</div>
                <div class="stat-label">SCORE</div>
            </div>
            <div class="stat-module">
                <div class="stat-val" id="velocity-val">0</div>
                <div class="stat-label">SPEED (m/s)</div>
            </div>
            <div class="stat-module">
                <div class="stat-val" id="combo-val">0</div>
                <div class="stat-label">COMBO</div>
            </div>
        </div>

        <div id="comms-log"></div>
        <div id="reticle"></div>

        <div class="bars-wrapper">
            <div class="player-hud">
                <div style="color:var(--neon-cyan); margin-bottom:5px;">OPERATOR STATUS</div>
                <div class="bar-frame"><div id="p-hp" class="hp-fill"></div></div>
                <div class="bar-frame" style="height:5px; border:none;"><div id="p-stam" class="stamina-fill"></div></div>
            </div>
            <div class="enemy-hud" id="enemy-ui" style="opacity:0;">
                <div style="color:var(--neon-red); margin-bottom:5px; text-align:left;">THREAT LEVEL</div>
                <div class="bar-frame"><div id="e-hp" class="hp-fill"></div></div>
            </div>
        </div>
    </div>
</div>

<script>
    /* --- SYSTEM CORE CONFIGURATION --- */
    const config = {
        minPunchSpeed: 8,      // Minimum velocity to register a hit
        hitCooldown: 300,      // ms between hits
        enemyAttackRate: 2000, // ms avg between attacks
        audioRate: 1.1
    };

    const state = {
        mode: 'menu',
        running: false,
        player: { hp: 100, stamina: 100, score: 0, combo: 0 },
        enemy: { hp: 100, state: 'IDLE', x: 0.5, y: 0.5, actionTimer: 0 },
        skeleton: [],
        lastFrameTime: 0,
        history: { rightWrist: {x:0, y:0}, leftWrist: {x:0, y:0} }
    };

    const els = {
        video: document.getElementById('webcam'),
        canvas: document.getElementById('game-canvas'),
        ctx: document.getElementById('game-canvas').getContext('2d'),
        hud: document.getElementById('hud-layer'),
        menu: document.getElementById('menu-overlay'),
        loader: document.getElementById('loader'),
        log: document.getElementById('comms-log')
    };

    let detector;
    let synth = window.speechSynthesis;

    /* --- INITIALIZATION --- */
    async function bootSystem(mode) {
        state.mode = mode;
        els.loader.style.display = 'block';
        
        try {
            await initCamera();
            detector = await poseDetection.createDetector(
                poseDetection.SupportedModels.MoveNet,
                { modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER }
            );
            
            startGame();
        } catch(e) {
            alert("System Failure: Camera access denied or WebGL error.");
        }
    }

    async function initCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false
        });
        els.video.srcObject = stream;
        return new Promise(r => els.video.onloadedmetadata = r);
    }

    function startGame() {
        els.menu.style.display = 'none';
        els.hud.style.display = 'block';
        els.canvas.width = els.video.videoWidth;
        els.canvas.height = els.video.videoHeight;
        
        if(state.mode === 'fight') {
            document.getElementById('enemy-ui').style.opacity = 1;
            log("COMBAT SIMULATION ENGAGED");
            speak("קרב התחיל. שמור פנים.");
        } else {
            log("TRAINING PROTOCOL ACTIVE");
            speak("מצב אימון. אני בודק טכניקה.");
        }

        state.running = true;
        requestAnimationFrame(gameLoop);
    }

    /* --- MAIN ENGINE LOOP --- */
    async function gameLoop(timestamp) {
        if(!state.running) return;

        const deltaTime = timestamp - state.lastFrameTime;
        state.lastFrameTime = timestamp;

        const poses = await detector.estimatePoses(els.video);
        
        els.ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);

        if (poses.length > 0) {
            const kp = poses[0].keypoints;
            const p = mapKeypoints(kp);
            
            // Core Logic
            analyzeBiomechanics(p, deltaTime);
            
            if(state.mode === 'fight') updateFightEngine(p, deltaTime);
            else updateCoachEngine(p);

            // Render Layers
            drawAugmentedReality(p);
        }

        requestAnimationFrame(gameLoop);
    }

    /* --- BIOMECHANICS ENGINE --- */
    function analyzeBiomechanics(p, dt) {
        // Calculate Velocity (Pixels per ms)
        const rwV = getVelocity(p.right_wrist, state.history.rightWrist, dt);
        const lwV = getVelocity(p.left_wrist, state.history.leftWrist, dt);
        
        const velocity = Math.max(rwV, lwV) * 10; // Scale up for display
        document.getElementById('velocity-val').innerText = Math.floor(velocity);

        // Update History
        state.history.rightWrist = { x: p.right_wrist.x, y: p.right_wrist.y };
        state.history.leftWrist = { x: p.left_wrist.x, y: p.left_wrist.y };

        return { velocity, rwV, lwV };
    }

    /* --- FIGHT ENGINE (The Smart Enemy) --- */
    function updateFightEngine(p, dt) {
        state.enemy.actionTimer += dt;

        // 1. Enemy Movement (Circle the player)
        const time = Date.now() * 0.001;
        state.enemy.x = (els.canvas.width / 2) + Math.sin(time) * 100;
        state.enemy.y = (els.canvas.height / 2) + Math.cos(time * 0.5) * 30;

        // 2. Enemy AI State Machine
        if(state.enemy.state === 'IDLE') {
            if(state.enemy.actionTimer > config.enemyAttackRate) {
                // Decide action based on player guard
                const playerGuarding = isGuarding(p);
                if(!playerGuarding && Math.random() > 0.3) {
                    setEnemyState('ATTACK');
                } else {
                    setEnemyState('BLOCK'); // Taunt/Block
                }
            }
        } 
        else if(state.enemy.state === 'ATTACK') {
            // Draw Warning
            drawWarningLine(state.enemy.x, state.enemy.y, p.nose.x, p.nose.y);
            
            if(state.enemy.actionTimer > 500) { // Impact moment
                if(!isGuarding(p)) {
                    takeDamage(10);
                } else {
                    speak("חסימה!");
                    log("ATTACK BLOCKED");
                }
                setEnemyState('IDLE');
            }
        }
        else if(state.enemy.state === 'HIT') {
            if(state.enemy.actionTimer > 400) setEnemyState('IDLE');
        }

        // 3. Player Attack Detection
        detectPlayerHit(p);
        
        // Render Enemy
        drawEnemy(state.enemy);
    }

    /* --- COACH ENGINE (Technique) --- */
    function updateCoachEngine(p) {
        // Guard Check
        if(!isGuarding(p)) {
            drawTarget(p.nose.x, p.nose.y, 'var(--neon-red)', 'PROTECT HEAD');
            if(Math.random() > 0.98) speak("תרים ידיים!");
        }

        // Punch Form Check
        const leftExt = p.left_wrist.x - p.left_shoulder.x; // Extension
        if(leftExt > 100) { // Jab Detected
             // Elbow check (Don't chicken wing)
             if(Math.abs(p.left_elbow.y - p.left_shoulder.y) > 50) {
                 log("ELBOW TOO LOW");
             }
        }
        
        // Squat/Duck Detection
        if(p.nose.y > els.canvas.height * 0.6) {
            log("GOOD DUCK");
        }
    }

    /* --- COMBAT LOGIC --- */
    function detectPlayerHit(p) {
        const hitZone = 80;
        const enemyHead = { x: state.enemy.x, y: state.enemy.y - 100 };
        
        // Check distance of wrists to enemy head
        const distR = getDist(p.right_wrist, enemyHead);
        const distL = getDist(p.left_wrist, enemyHead);

        // Get velocity from UI for now (optimization)
        const velocity = parseInt(document.getElementById('velocity-val').innerText);

        if((distR < hitZone || distL < hitZone) && velocity > config.minPunchSpeed) {
            if(state.enemy.state !== 'HIT' && state.enemy.state !== 'BLOCK') {
                // HIT!
                state.enemy.hp -= 5 + (velocity/5);
                state.player.score += 100;
                state.player.combo++;
                setEnemyState('HIT');
                
                // Audio/Visual Feedback
                speak(["בום", "יפה", "חזק", "פגיעה"][Math.floor(Math.random()*4)]);
                createExplosion(enemyHead.x, enemyHead.y);
                updateHUD();

                if(state.enemy.hp <= 0) {
                    speak("נוק אאוט! ניצחון מוחץ.");
                    state.enemy.hp = 100;
                    state.player.score += 1000;
                }
            } else if (state.enemy.state === 'BLOCK') {
                log("ENEMY BLOCKED");
                createSparks(enemyHead.x, enemyHead.y);
            }
        }
    }

    function takeDamage(amount) {
        state.player.hp -= amount;
        document.body.classList.add('damage-flash');
        setTimeout(() => document.body.classList.remove('damage-flash'), 300);
        speak("נפגעת!");
        state.player.combo = 0;
        updateHUD();
        
        if(state.player.hp <= 0) {
            speak("הפסדת. קום על הרגליים.");
            state.player.hp = 100;
            state.enemy.hp = 100;
        }
    }

    /* --- RENDERING (CANVAS) --- */
    function drawEnemy(e) {
        const ctx = els.ctx;
        const cx = e.x;
        const cy = e.y;

        ctx.save();
        
        // Dynamic Color
        let color = '#fff'; // Idle
        if(e.state === 'ATTACK') color = '#ff003c';
        if(e.state === 'BLOCK') color = '#00f3ff';
        if(e.state === 'HIT') color = '#ffff00';

        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;

        // Futuristic Hologram Body
        // Head
        ctx.beginPath(); 
        ctx.arc(cx, cy - 100, 30, 0, Math.PI*2);
        ctx.moveTo(cx - 30, cy - 110); ctx.lineTo(cx + 30, cy - 110); // Visor
        ctx.stroke();

        // Torso (Hexagon style)
        ctx.beginPath();
        ctx.moveTo(cx - 40, cy - 60); ctx.lineTo(cx + 40, cy - 60);
        ctx.lineTo(cx + 20, cy + 80); ctx.lineTo(cx - 20, cy + 80);
        ctx.lineTo(cx - 40, cy - 60);
        ctx.stroke();

        // Arms (Based on state)
        if(e.state === 'BLOCK') {
            ctx.strokeRect(cx - 50, cy - 120, 40, 80); // Left Guard
            ctx.strokeRect(cx + 10, cy - 120, 40, 80); // Right Guard
        } else if (e.state === 'ATTACK') {
             // Punching Arm (Huge Perspective)
             ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
             ctx.beginPath(); ctx.arc(cx + 50, cy - 50, 80, 0, Math.PI*2); ctx.fill();
        } else {
             // Idle Arms
             ctx.moveTo(cx - 40, cy - 60); ctx.lineTo(cx - 60, cy + 20);
             ctx.moveTo(cx + 40, cy - 60); ctx.lineTo(cx + 60, cy + 20);
             ctx.stroke();
        }

        // HP Ring
        ctx.beginPath();
        ctx.arc(cx, cy - 100, 45, 0, Math.PI * 2 * (e.hp/100));
        ctx.strokeStyle = e.hp > 50 ? '#0f0' : '#f00';
        ctx.stroke();

        ctx.restore();
    }

    function drawAugmentedReality(p) {
        const ctx = els.ctx;
        
        // Draw Skeleton overlay (Cybernetic Style)
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.4)';
        ctx.lineWidth = 2;
        
        // Joints
        const joints = ['left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow', 'left_wrist', 'right_wrist'];
        joints.forEach(j => {
            if(p[j].score > 0.5) {
                ctx.beginPath();
                ctx.arc(p[j].x, p[j].y, 5, 0, Math.PI*2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                // Data tag
                ctx.font = '10px monospace';
                ctx.fillStyle = 'cyan';
                ctx.fillText(j.split('_')[1].toUpperCase(), p[j].x + 10, p[j].y);
            }
        });

        // Skeleton Lines
        const connections = [['left_shoulder','right_shoulder'], ['left_shoulder','left_elbow'], ['left_elbow','left_wrist'], ['right_shoulder','right_elbow'], ['right_elbow','right_wrist']];
        connections.forEach(([s, e]) => {
            if(p[s].score > 0.5 && p[e].score > 0.5) {
                ctx.beginPath(); ctx.moveTo(p[s].x, p[s].y); ctx.lineTo(p[e].x, p[e].y); ctx.stroke();
            }
        });
    }

    function createExplosion(x, y) {
        const ctx = els.ctx;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(x, y, 50, 0, Math.PI*2); ctx.fill();
    }

    function createSparks(x, y) {
        // Simple visual for block
        const ctx = els.ctx;
        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x-20, y-20); ctx.lineTo(x+20, y+20); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+20, y-20); ctx.lineTo(x-20, y+20); ctx.stroke();
    }

    function drawWarningLine(x1, y1, x2, y2) {
        const ctx = els.ctx;
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
        ctx.lineWidth = 5 + Math.random() * 5; // Flicker
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
    }

    function drawTarget(x, y, color, text) {
        const ctx = els.ctx;
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.strokeRect(x - 40, y - 40, 80, 80);
        ctx.fillStyle = color;
        ctx.font = "20px Orbitron";
        ctx.fillText(text, x - 50, y - 50);
    }

    /* --- HELPERS --- */
    function mapKeypoints(kp) {
        const p = {};
        kp.forEach(pt => p[pt.name] = pt);
        return p;
    }

    function isGuarding(p) {
        // Are wrists above shoulders and close to nose?
        return (p.right_wrist.y < p.right_shoulder.y && p.left_wrist.y < p.left_shoulder.y);
    }

    function getVelocity(curr, prev, dt) {
        if(dt === 0) return 0;
        const dist = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
        return dist / dt;
    }

    function getDist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    function setEnemyState(s) {
        state.enemy.state = s;
        state.enemy.actionTimer = 0;
    }

    function updateHUD() {
        document.getElementById('p-hp').style.width = state.player.hp + '%';
        document.getElementById('e-hp').style.width = state.enemy.hp + '%';
        document.getElementById('score-val').innerText = state.player.score;
        document.getElementById('combo-val').innerText = state.player.combo;
    }

    function log(msg) {
        const el = document.createElement('div');
        el.className = 'log-entry';
        el.innerText = `> ${msg}`;
        els.log.prepend(el);
        if(els.log.children.length > 5) els.log.lastChild.remove();
    }

    function speak(txt) {
        if(synth.speaking) return;
        const u = new SpeechSynthesisUtterance(txt);
        u.lang = 'he-IL';
        u.rate = 1.2;
        synth.speak(u);
    }

</script>
</body>
</html>
