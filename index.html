<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HORIZON: MOBILE 8K</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@700&display=swap');
        
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; user-select: none; -webkit-user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* MENU */
        #menu {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 20; transition: opacity 0.5s;
        }
        h1 { color: #fff; font-size: 3rem; text-transform: uppercase; margin-bottom: 10px; text-shadow: 0 0 20px #00ccff; }
        .subtitle { color: #888; letter-spacing: 5px; margin-bottom: 40px; }
        
        .vehicle-select { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .v-card {
            width: 140px; height: 140px; background: #1a1a1a; border: 2px solid #333; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; color: white;
        }
        .v-card:hover, .v-card:active { border-color: #00ccff; background: #222; transform: scale(1.05); }
        .v-icon { font-size: 3rem; margin-bottom: 10px; }
        .v-name { font-size: 1rem; font-weight: bold; }

        /* HUD */
        #hud { display: none; width: 100%; height: 100%; }
        
        .speed-box {
            position: absolute; top: 20px; right: 20px; text-align: right;
        }
        .speed-val { font-size: 4rem; color: #fff; line-height: 0.8; text-shadow: 0 0 10px #ff0055; }
        .speed-label { color: #aaa; font-size: 1rem; }

        /* MOBILE CONTROLS */
        .controls-area {
            position: absolute; bottom: 20px; width: 100%; height: 150px;
            pointer-events: auto; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
        }
        
        .d-pad { display: flex; gap: 10px; align-items: flex-end; }
        .pedals { display: flex; gap: 10px; align-items: flex-end; }

        .btn {
            width: 70px; height: 70px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: white; font-size: 2rem; display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); touch-action: none;
        }
        .btn:active { background: rgba(0, 204, 255, 0.4); border-color: #00ccff; transform: scale(0.95); }
        .btn.brake { border-color: #ff0055; }
        .btn.brake:active { background: rgba(255, 0, 85, 0.4); }

        /* Hides controls on desktop if wanted, but useful for testing */
        @media (min-width: 1024px) {
            .controls-hint { display: block; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #666; }
        }
    </style>
</head>
<body>

    <div id="menu">
        <h1>Horizon 8K</h1>
        <div class="subtitle">SELECT YOUR RIDE</div>
        <div class="vehicle-select">
            <div class="v-card" onclick="startGame('supercar')">
                <div class="v-icon">üèéÔ∏è</div>
                <div class="v-name">VENOM GT</div>
            </div>
            <div class="v-card" onclick="startGame('truck')">
                <div class="v-icon">üöô</div>
                <div class="v-name">TITAN 4x4</div>
            </div>
            <div class="v-card" onclick="startGame('bike')">
                <div class="v-icon">üèçÔ∏è</div>
                <div class="v-name">NINJA ZX</div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="hud">
            <div class="speed-box">
                <div class="speed-val" id="speed-disp">0</div>
                <div class="speed-label">KM/H</div>
            </div>

            <div class="controls-area">
                <div class="d-pad">
                    <div class="btn" id="btn-left">‚óÑ</div>
                    <div class="btn" id="btn-right">‚ñ∫</div>
                </div>
                <div class="pedals">
                    <div class="btn brake" id="btn-brake">S</div>
                    <div class="btn" id="btn-gas">W</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, composer, player;
        let terrain, roadLines = [];
        let speed = 0, angle = 0;
        let currentVehicleType = 'supercar';
        
        const inputs = { up: false, down: false, left: false, right: false };
        const clock = new THREE.Clock();

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            // High quality fog
            scene.fog = new THREE.FogExp2(0x0a0a20, 0.0025);
            scene.background = new THREE.Color(0x0a0a20);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Max sharpness
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Post Processing (Bloom)
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.strength = 0.8; bloom.radius = 0.5; bloom.threshold = 0.7;
            composer.addPass(bloom);

            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffaa00, 2);
            sun.position.set(100, 100, -50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; 
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // Environment
            createInfiniteRoad();
            
            // Listeners
            setupControls();
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- VEHICLE BUILDER ---
        function createVehicle(type) {
            const container = new THREE.Group();
            
            // Materials
            const bodyMat = new THREE.MeshStandardMaterial({ color: type=='supercar'?0xff0044:type=='truck'?0x0088ff:0x00ff88, roughness: 0.2, metalness: 0.8 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0, metalness: 1.0 });
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.2 });

            if (type === 'supercar') {
                // Sleek Body
                const bodyGeo = new THREE.BoxGeometry(1.8, 0.6, 4.2);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.6; body.castShadow = true;
                container.add(body);
                
                // Cabin
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 2.0), glassMat);
                cabin.position.set(0, 1.0, -0.2);
                container.add(cabin);
                
                // Spoiler
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 0.5), bodyMat);
                wing.position.set(0, 1.1, 1.8);
                container.add(wing);

                // Wheels
                addWheels(container, 0.35, 0.3, 0.9, 1.3, wheelMat, rimMat);
            } 
            else if (type === 'truck') {
                // Big Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.2, 4.5), bodyMat);
                body.position.y = 1.2; body.castShadow = true;
                container.add(body);
                
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.8, 2.5), glassMat);
                cabin.position.set(0, 2.0, -0.5);
                container.add(cabin);

                // Big Wheels
                addWheels(container, 0.6, 0.5, 1.3, 1.5, wheelMat, rimMat);
            }
            else if (type === 'bike') {
                // Bike Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 2.0), bodyMat);
                body.position.y = 0.8; body.castShadow = true;
                container.add(body);
                
                const wind = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.5), glassMat);
                wind.position.set(0, 1.3, -0.5);
                wind.rotation.x = -0.5;
                container.add(wind);

                // Bike Wheels (Only 2)
                const w1 = createWheel(0.4, 0.2, wheelMat, rimMat); w1.position.set(0, 0.4, 1.0);
                const w2 = createWheel(0.4, 0.2, wheelMat, rimMat); w2.position.set(0, 0.4, -1.2); // Steering wheel
                container.add(w1); container.add(w2);
                container.wheels = [w2]; // Only front steers visually
            }

            // Headlights (Common)
            const hl = new THREE.SpotLight(0xffffff, 4, 80, 0.6, 0.5, 1);
            hl.position.set(0, 1, -2);
            hl.target.position.set(0, 0, -10);
            container.add(hl); container.add(hl.target);

            return container;
        }

        function addWheels(parent, radius, width, xOff, zOff, mat, rimMat) {
            parent.wheels = [];
            const positions = [
                {x: xOff, z: -zOff, steer: true}, {x: -xOff, z: -zOff, steer: true},
                {x: xOff, z: zOff, steer: false}, {x: -xOff, z: zOff, steer: false}
            ];
            positions.forEach(p => {
                const w = createWheel(radius, width, mat, rimMat);
                w.position.set(p.x, radius, p.z);
                if(p.steer) parent.wheels.push(w); // Add to steerable list
                parent.add(w);
            });
        }

        function createWheel(r, w, mat, rimMat) {
            const group = new THREE.Group();
            const tire = new THREE.Mesh(new THREE.CylinderGeometry(r, r, w, 24), mat);
            tire.rotation.z = Math.PI / 2; tire.castShadow = true;
            
            const rim = new THREE.Mesh(new THREE.CylinderGeometry(r*0.6, r*0.6, w+0.01, 16), rimMat);
            rim.rotation.z = Math.PI / 2;
            
            group.add(tire); group.add(rim);
            return group;
        }

        // --- INFINITE ROAD ---
        function createInfiniteRoad() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            // Distort vertices for mountains
            const pos = groundGeo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i);
                if (Math.abs(x) > 30) {
                    pos.setZ(i, Math.random() * 20 + Math.abs(x)*0.2); // Mountains on sides
                }
            }
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x050505, roughness: 0.8, metalness: 0.2,
                flatShading: true
            });
            terrain = new THREE.Mesh(groundGeo, groundMat);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Road Strip
            const road = new THREE.Mesh(new THREE.PlaneGeometry(40, 2000), new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.5}));
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.05;
            road.receiveShadow = true;
            scene.add(road);

            // Glowing Lines (Neon)
            for(let i=0; i<20; i++) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 10), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                line.position.set(0, 0.1, i * -50);
                scene.add(line);
                roadLines.push(line);
            }
        }

        // --- CONTROLS SETUP ---
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if(e.key==='w'||e.key==='ArrowUp') inputs.up = true;
                if(e.key==='s'||e.key==='ArrowDown') inputs.down = true;
                if(e.key==='a'||e.key==='ArrowLeft') inputs.left = true;
                if(e.key==='d'||e.key==='ArrowRight') inputs.right = true;
            });
            document.addEventListener('keyup', (e) => {
                if(e.key==='w'||e.key==='ArrowUp') inputs.up = false;
                if(e.key==='s'||e.key==='ArrowDown') inputs.down = false;
                if(e.key==='a'||e.key==='ArrowLeft') inputs.left = false;
                if(e.key==='d'||e.key==='ArrowRight') inputs.right = false;
            });

            // Touch (Mobile)
            const addTouch = (id, key) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); inputs[key] = true; el.style.background = 'rgba(0,204,255,0.6)'; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); inputs[key] = false; el.style.background = ''; });
            };
            
            addTouch('btn-gas', 'up');
            addTouch('btn-brake', 'down');
            addTouch('btn-left', 'left');
            addTouch('btn-right', 'right');
        }

        window.startGame = function(type) {
            currentVehicleType = type;
            document.getElementById('menu').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('menu').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
            }, 500);

            if(player) scene.remove(player);
            player = createVehicle(type);
            scene.add(player);
            
            animate();
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();

            // Physics Stats
            const maxSpeed = currentVehicleType === 'supercar' ? 3.5 : currentVehicleType === 'truck' ? 2.5 : 3.8;
            const accel = currentVehicleType === 'truck' ? 0.01 : 0.02;

            // Drive Logic
            if(inputs.up) speed += accel;
            if(inputs.down) speed -= accel;
            speed *= 0.98; // Friction
            speed = Math.min(Math.max(speed, -1), maxSpeed);

            // Steering
            if(Math.abs(speed) > 0.1) {
                const turn = inputs.left ? 1 : inputs.right ? -1 : 0;
                angle += turn * dt * 2;
                
                // Visual tilt
                player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, turn * 0.1, 0.1);
                if(currentVehicleType === 'bike') player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, turn * 0.5, 0.1); // Bike leans more
                
                // Wheel turn
                if(player.wheels) player.wheels.forEach(w => w.rotation.y = turn * 0.4);
            }

            // Move Car (Visual only, world moves around car)
            // Infinite Runner trick: Reset Z of lines
            roadLines.forEach(line => {
                line.position.z += speed * 20;
                if(line.position.z > 20) line.position.z -= 1000;
            });
            
            // Camera follow
            const camDist = currentVehicleType === 'truck' ? 12 : 8;
            const camHeight = currentVehicleType === 'truck' ? 6 : 4;
            
            // Simple sway
            player.position.x += (inputs.left ? 0.2 : inputs.right ? -0.2 : 0) * (speed/maxSpeed);
            player.position.x = Math.max(-18, Math.min(18, player.position.x)); // Road limits

            camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x, 0.1);
            camera.position.y = camHeight;
            camera.position.z = player.position.z + camDist + (speed * 2);
            camera.lookAt(player.position.x, player.position.y, player.position.z - 10);

            // Update Speedometer UI
            document.getElementById('speed-disp').innerText = Math.floor(Math.abs(speed) * 80);

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
